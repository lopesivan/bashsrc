#!/bin/bash

#-------------------------------------------------------
# Script: bashsrc 1.0.0
# Descrição: Utilitário para consulta de documentações
# Desenvolvido por: Juliano Santos [SHAMAN]
#-------------------------------------------------------

readonly BASENAME=${0##*/}
readonly BASHSRC_VERSION=1.0.0

if [[ ${#@} -eq 0 ]]; then
	echo "Uso: $BASENAME [OPÇÕES]"
	echo "Tente '$BASENAME --help' para mais informações."
	exit 0
elif [[ ${BASH_VERSINFO[0]} -lt 4 ]]; then
	exec 1>&2
	echo "$BASENAME: erro: versão do 'bash' incompatível."
	echo "atual: $BASH_VERSION" 
	echo "requerida: 4.0 ou superior"
	exit 1
elif [[ ! $BASHSRC_PATH ]]; then
	man ./intro.gz
	exit 1
elif [[ ! -d "$BASHSRC_PATH" ]]; then
	echo "$BASENAME: erro: '$BASHSRC_PATH' diretório não encontrado" 1>&2
	exit 1
fi

function usage()
{
	echo "$BASENAME: ferramenta para consulta de documentação e ambiente."
	echo "Uso: $BASENAME [OPÇÕES]"
	echo
	echo "Argumentos obrigatórios para opções longas também são para opções curtas."
	echo
	echo "-l, --list                    - Lista os sources disponíveis em '\$BASHSRC_PATH'"
	echo "-e, --env                     - Exibe o ambiente configurado em '\$BASHSRC_PATH'."
	echo "-d, --doc <src>[.funcname]    - Exibe a documentação do source ou função."
	echo "                                'src' refere-se ao nome da biblioteca a ser"
	echo "                                consultada, omitindo a extensão '.sh' do arquivo."
 	echo "                                Se '.funcname' for omitido é retornado o protótipo"
	echo "                                de todas as funções disponíveis em 'src'."
	echo "-c, --check-conflicts           Verifica se há conflito de tipos em bibliotecas."
	echo "-h, --help                      Exibe ajuda e sai."
	echo "-v, --version                   Exibe a versão e sai."
	echo
	echo "Para visualizar a documentação inicial, digite:"
	echo "$ $BASENAME man"

	exit 1
}

function view_doc()
{
	local srcname=(${1/./ })
	local srcfile=${srcname[0]}.sh
	local srcdir=$BASHSRC_PATH/src
	local line flags match prefix ver type

	if [[ ${#srcname[@]} -eq 0 ]]; then
		echo "$BASENAME: nome do source requerido" 1>&2
		return 1
	elif [[ ! -e "$srcdir/$srcfile" ]]; then
		echo "$BASENAME: $srcname: source não encontrado" 1>&2
		return 1
	fi
	
	shopt -s extglob globasciiranges
	set -f
	
	flags=(
'*( )+(#)*( )+(\*)*(*)'
'*( )+(#)*( )@(func)+( )*(*)'
'*( )@(__TYPE__)\[+([a-zA-Z0-9._])\]=*(*)'
'*( )@(readonly)+( )?(-[aA]+( ))+([a-zA-Z])*([a-zA-Z0-9_])?(=*(*))'
'*( )@(declare)+( )?(-*([^r])r*([^r])+( ))+([a-zA-Z])*([a-zA-Z0-9_])?(=*(*))'
'*( )+(#)*( )@(func)+( )'
'*( )+([^#])'
'*( )@(__TYPE__)'
'*( )+([a-zA-Z0-9_.])'
'*( )'
)
	
	if [[ ${#srcname[@]} -eq 1 ]]; then
		while read line; do
			case $line in
				${flags[0]}) echo "${line#${flags[0]}}";;
				${flags[1]}) echo "${line#+(#)}";;
				${flags[2]}) [[ $line =~ \[([^]]+)\] ]] && echo "type ${BASH_REMATCH[1]}";;
				${flags[3]}|${flags[4]}) echo "$line";;
			esac
		done < "$srcdir/$srcfile"
	else
		prefix=${1#builtin.}; prefix=${prefix##*/}
		while read line; do
			[[ $ver -eq 1 && $line == ${flags[6]} ]] || 
			[[ $ver -eq 2 && $line == ${flags[9]} ]] && break

			if [[ $line == @(${flags[5]}${prefix}*(+( )*(*))) ]]; then
				ver=1; match=1
			elif [[ $line == ${flags[7]}\[@(${1#*.})\]*(*) ]]; then
				[[ $line =~ \[([^]]+)\] ]] 
				type=${BASH_REMATCH[1]}
				echo "type $type"
				echo
				echo "Implementa o(s) método(s) do objeto '$type', onde 'S' é o identificador"
				echo "da variável implementada."
				echo
				echo "Métodos:"
				echo
				ver=2
				match=1
			fi
			
			case $ver in
				1) 	echo "${line#+(#)}";;
				2)	[[ $line == ${flags[8]} ]] && echo "S.${line##*.}";;
			esac
		done < "$srcdir/$srcfile"
		
		if ! [[ $match ]]; then
			echo "$BASENAME: '$1' documentação não encontrada." 1>&2
			return 1
		fi
	fi
	
	return 0
}

function check_conflicts()
{
   local srcfile cur old line
   local re='^[^#]*__SRC_TYPES\[([^]]+)\]='

	while read srcfile; do
		while read line; do
			[[ "$line" =~ $re ]] && echo "${BASH_REMATCH[1]}|$srcfile"
		done < "$srcfile"
	done < <(list_sources) | sort -d -t'|' -k1 | while read cur; do
		if [[ "${old%|*}" == "${cur%|*}" ]]; then
			echo -e "Conflito(s):\n"
			echo "Tipo: ${old%|*}"
			echo "Source 1: ${old#*|}"
			echo "Source 2: ${cur#*|}"
			echo
			c=1
		fi
		old="$cur"
	done

	return 0
}

function list_sources()
{
	local dir file
	local listdir=${1:-$BASHSRC_PATH/src}

	for dir in "${listdir[@]}"; do
		for file in "$dir/"*; do
			if [[ -d "$file" ]]; then
				list_sources "$file"
			else
				echo "$file"
			fi
		done
	done

	return 0
}


case $1 in
	-d|--doc) view_doc $2;;
	-l|--list) list_sources;;
	-e|--env) printf "BASHSRC_PATH=%s\nPATH=%s\n" $BASHSRC_PATH $PATH;;
	-c|--check-conflicts) check_conflicts;;
	-h|--help) usage;;
	-v|--version) echo "$BASENAME $BASHSRC_VERSION";;
	man) man $BASHSRC_PATH/bin/intro.gz;;
	*) 	echo "$BASENAME: '$1' opção inválida" 1>&2
		echo "Tente '$BASENAME --help' para mais informações." 1>&2;;
esac

exit $?
